---
format: 
  revealjs:
    embed-resources: true
    code-fold: true
    math: mathjax
    css: CSS/custom.css
    slide-number: true
    transition: fade
    incremental: true
    center-title-slide: false
    backgroundTransition: fade
highlight-style: a11y
code-link: true
height: 1080
width: 1600
execute: 
  eval: true
---
## {background-image=Background/bim1.png}
::: {style="text-align: center; margin-top: 100px;"}

<span style="font-size: 3em; color: #003366;">
Análisis Demográfico 1
</span>

----

<span style="font-size: 2em; margin-top: 0.5em;">
Dr. Víctor Manuel García Guerrero
</span>

<span style="font-size: 1.5em; text-transform: lowercase;">
vmgarcia@colmex.mx
</span>

![](Input/LogoCEDUA.png){.absolute top="585" left="1200" width="450"} 
![](Input/colmex.png){.absolute top="610" left="600" width="450"} 
![](Input/logo_colmex.png){.absolute top="600" left="70" width="450"}
:::

## `¿Qué es la demografía?` {background-image=Background/bim1.png}

::: {.callout-tip .centered-callout title=""}
La **demografía** es la ciencia que tiene por objeto el estudio de la poblaciones humanas tratando, desde un punto de vista principalmente cuantitativo, su dimensión, estructura, evolución y características generales.
:::

## `Población`  {background-image=Background/bim1.png}

::: {.callout-tip .centered-callout title=""}
-   Colección de personas vivas en un punto determinado en el tiempo que cumplen con ciertos criterios.
    -   La población de Guatemala de 1 de julio del 2010
    -   La población de mujeres indígenas en edad reproductiva en el sureste mexicano al 1 de enero de 2011
-   Colectividad que persiste a lo largo del tiempo auqnue sus miembros estén en continuo cambio.
    -   La población de Mexico
:::

## `¿Qué es la demografía?` 

::: {.callout-tip .centered-callout title=""}
“\[...\] en definitiva puede considerarse que las investigaciones realizadas en el marco restringido del análisis demográfico constituyen el ‘nucleo’ de la demografía como ciencia, bien entendido que tales investigaciones conciernen exclusivamente al estudio del tamaño, distribución territorial y composición de la población como así también a sus cambios y a los componentes de tales cambios”
:::

##  `.`

![](Input/demografia.png){.absolute top="50" left="50" width="1500"}


##  `.`

![](Input/demog_google.png){.absolute  top="50" left="50" width="1500"}


## ``


![](Input/demog_google_esp.png){.absolute  width="2500"}


## ``

![](Input/bio_socio.png){.absolute  top="100" left="50" width="1500"}

##``

![](Input/bio_socio_esp.png){.absolute top="100" left="50" width="1500"}

## ``

![](Input/components.png){.absolute  top="100" left="50" width="1500"}

## ``

![](Input/components_esp.png){.absolute  top="100" left="50" width="1500"}


## ``

![](Input/demo1.png){.absolute top="50" left="50" width="1500"}


## ``

![](Input/demo2.png){.absolute  top="10" left="50" width="1500"}

## `.`

![](Input/demo3.png){.absolute  top="50" left="50" width="500"}

## `.`

![](Input/demo4.png){.absolute  top="50" left="50" width="1500"}

## `.`

![](Input/demo5.png){.absolute  top="50" left="50" width="1500"}

## `.`

![](Input/demo6.png){.absolute  top="50" left="50" width="1500"}

## `.`

![](Input/demo7.png){.absolute  top="50" left="50" width="1500"}


## `¿Qué es la demografía?` 

::: {.callout-tip .centered-callout title=""}
-   Conceptos basicos y medidad
-   Fuentes de información en demografía (evaluación y corrección )
-   Tasas por edad específica y probabilidad
-   Procesos de decremento simple: La tabla de mortalidad
-   Procesos de decremento múltiple
-   Fecundidad y reproducción
-   Modelación de los patrones por edad de los eventos vitales 
:::

## `Bibliografía` 

::: r-stack
![](Input/whydemographymatters.jpg){.absolute top="50" left="415" width="700"}

![](Input/proyeccionesypoliticas.jpg){.fragment top="50" left="415" width="700"} ![](Input/appliedmathematical.jpg){.fragment top="50" left="415" width="700"}

![](Input/tools.png){.fragment top="50" left="415" width="700"}

![](Input/preston.jpg){.fragment top="50" left="415" width="700"}

![](Input/rowland.jpg){.fragment top="50" left="415" width="700"}

![](Input/swanson.jpg){.fragment top="50" left="415" width="700"}

![](Input/biodemography.jpg){.fragment top="50" left="415" width="700"} ![](Input/salgueiro.jpg){.fragment top="50" left="415" width="700"}

![](Input/watcher.jpg){.fragment top="50" left="415" width="700"}

![](Input/poston.jpg){.fragment top="50" left="415" width="700"}

![](Input/human.png){.fragment top="50" left="415" width="700"}
:::

## `Evaluación` 

::: {.callout-tip  title=""}
-   2 tareas examen 30%
-   1 examen final 50%
-   Tareas 20%
:::

## `Materiales` 

::: {.callout-tip  title=""}
-   Computadora (con R y RStudio instalado)
-   Pluma y lápiz
-   Cuaderno carta cuadro chico (obligatorio)
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title=""}
-   Censos (de facto, de jure)
-   Estadísticas Vitales
-   Encuestas
-   Fuentes secundarias( estimaciones y proyecciones, repositorios estadarizados)
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title="Censo de facto"}
Es un método de conteo de individuos basado en dónde se encuentran físicamente en el momento del censo, independientemente de su lugar de residencia habitual. Puede ser particularmente útil para ciertas necesidades de recopilación de datos a corto plazo, pero puede no siempre proporcionar la imagen más precisa para la planificación y asignación de recursos a largo plazo. 
\* Presencia física 
\* Instantánea en el tiempo 
\* Enumeración simplificada
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title="Ventajas de un censo de facto"}
-   Simplicidad: Más fácil de administrar porque solo considera d ́onde están las personas el día del censo.
-   Reducción del doble conteo: Minimiza el riesgo de contar a los individuos más de una vez, especialmente aquellos con múltiples residencias.
-   Eficiente para Poblaciones Temporales: Captura datos sobre poblaciones temporales como turistas, viajeros de negocios y trabajadores estacionales.
-   Recopilación de datos inmediata: Facilita una recopilación de datos más rápida ya que no implica rastrear residencias habituales o patrones de migración.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title="Desventajas de un censo de facto"}
-   Sesgo temporal: Puede no representar con precisión a la población residente habitual, particularmente en áreas con alta población de turistas o transitoria.
-   Inexactitud para la asignación de recursos: Puede llevar a inexactitudes en la asignación de recursos y la planificación de políticas, ya que no refleja dónde viven y usan servicios las personas habitualmente.
-   Sobrerrepresentación de ciertas áreas: Las áreas con eventos o grandes poblaciones temporales (por ejemplo, convenciones, festivales) pueden estar sobrerrepresentadas.
-   Desconsideración de la residencia habitual: Ignora dónde residen típicamente los individuos y contribuyen a la vida comunitaria.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title="Censo de jure"}
Es un método de conteo de individuos basado en su lugar de residencia habitual, independientemente de dónde se encuentren físicamente en el momento del censo. Un censo de jure es esencial para obtener una visión precisa y estable de la población residente, crucial para una planificación efectiva y la asignación de recursos a largo plazo.

-   Lugar de residencia habitual.
-   Reflejo de la residencia permanente.
-   Complejidad de enumeración.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip  title="Ventajas de un censo de jure"}
-   Precisión en la planificación de recursos: Proporciona datos más precisos para la asignaci ́on de recursos y la planificaci ́on de pol ́ıticas pu ́blicas, reflejando la residencia permanente de la poblaci ́on.
-   Representaci ́on exacta: Mejora la precisión en la representación política y distribución de distritos electorales.
-   Datos estables: Ayuda a obtener una imagen m ́as estable y menos fluctuante de la población , útil para la planificación a largo plazo.
-   Adecuado para políticas sociales: Proporciona información relevante para servicios sociales, infraestructura y desarrollo comunitario, basada en la residencia habitual de las personas.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="Desventajas de un censo de jure"}
-   Complejidad y costos: Más difícil ıcil y costoso de administrar debido a la necesidad de verificar la residencia habitual.
-   Riesgo de doble conteo: Puede haber problemas con individuos que tienen múltiples residencias o migran frecuentemente, lo que puede llevar a errores o doble conteo.
-   Subnotificación: Algunos individuos pueden no ser contados si no se encuentran en su residencia habitual el día del censo o si no se reportan correctamente.
-   Desafíos de enumeración: Puede ser difícil rastrear y contar a personas sin hogar, nómadas, o aquellos en situaciones de vivienda inestables.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="En resumen"}
-   Censo De Jure: Cuenta a los individuos según su lugar de residencia habitual, proporcionando datos sobre donde la población vive y usa servicios regularmente.
-   Censo De Facto: Cuenta a los individuos según su ubicación física el día del censo, ofreciendo una instantánea de la población en un momento específico.
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="Ventajas de los censos"}
-   Datos Completos
-   Precisión
-   Referencia
-   Asignación de recursos Análisis de tendencias
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="Limitaciones de los censos"}
-   Costo
-   Consumo de tiempo
-   Desafiós logísticos
-   Frecuencia
-   Preocupaciones de privacidad
-   No respuesta (subcobertura)
-   Mala declaración de edad y sexo
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="Mala declaración de edad y sexo"}
-   Inexactitud de datos
-   Tendencias demográficas distorsionadas
-   Mala asignación de recursos
-   Implicaciones políticas
-   Integridad del censo
:::

## `Fuentes de información en demografía` 

::: {.callout-tip title="Mitigación de la mala declaración de edad y sexo"}
-   Capacitación de enumeradores.
-   Campañas de concientizacin pú́blica
-   Uso de tecnología.
-   Verificación cruzada.
:::

## `Fuentes de información en demografía` {auto-animate=true}

<!-- bloque 1-->
::: {style="font-size: 1.2em; color: grey; margin-top: -10px;"}
Operaciones en bases de datos
:::

::: {.callout-tip  title="Left join"}
Un **left join** es una operación en bases de datos que combina dos tablas, con base a una columna en común entre ellas y tomando en cuenta todas las filas de la tabla izquierda. Si no hay coincidencias en la en la tabla derecha, entonces éstas aparecenran con valores *null* en la nueva tabla.
:::

## `Fuentes de información en demografía` {auto-animate=true}

<!-- Bloque 2-->
::: {style="font-size: 1.2em; color: grey; margin-top: -10px;"}
Operaciones en bases de datos-Ejemplo
:::

:::: {.columns}

::: {.column width="60%"}
```{.r code-line-numbers="5-9"}
# Cargar el paquete dplyr
library(dplyr)

# Crear la primera tabla (izquierda)
tabla_izq <- data.frame(
  id = c(1, 2, 3, 4),
  nombre = c("Juan", "María", "Pedro", "Ana")
)

# Crear la segunda tabla (derecha)
tabla_der <- data.frame(
  id = c(1, 3, 4, 5),
  ciudad = c("Madrid", "Barcelona", "Valencia", "Sevilla")
)

# Realizar el left join
resultado <- left_join(tabla_A, tabla_B, by = "id")

```
:::

::: {.column width="40%"}
![](Input/izq.png){.absolute}
:::

::::


## `Fuentes de información en demografía` {auto-animate=true}

<!-- Bloque 3-->
::: {style="font-size: 1.2em; color: grey; margin-top: -10px;"}
Operaciones en bases de datos-Ejemplo
:::

:::: {.columns}

::: {.column width="60%"}
```{.r code-line-numbers="10-14"}
# Cargar el paquete dplyr
library(dplyr)

# Crear la primera tabla (izquierda)
tabla_izq <- data.frame(
  id = c(1, 2, 3, 4),
  nombre = c("Juan", "María", "Pedro", "Ana")
)

# Crear la segunda tabla (derecha)
tabla_der <- data.frame(
  id = c(1, 3, 4, 5),
  ciudad = c("Madrid", "Barcelona", "Valencia", "Sevilla")
)

# Realizar el left join
resultado <- left_join(tabla_A, tabla_B, by = "id")
```
::: {.callout-note title="Nota"}
Observe que en la tabla "derecha" no hay coincidencias para el id=2
:::
:::

::: {.column width="40%"}
![](Input/der.png){.absolute}
:::

::::


## `Fuentes de información en demografía` {auto-animate=true}

<!-- Bloque 4-->
::: {style="font-size: 1.2em; color: grey; margin-top: -10px;"}
Operaciones en bases de datos-Ejemplo
:::

:::: {.columns}

::: {.column width="60%"}
```{.r code-line-numbers="16-17"}
# Cargar el paquete dplyr
library(dplyr)

# Crear la primera tabla (izquierda)
tabla_izq <- data.frame(
  id = c(1, 2, 3, 4),
  nombre = c("Juan", "María", "Pedro", "Ana")
)

# Crear la segunda tabla (derecha)
tabla_der <- data.frame(
  id = c(1, 3, 4, 5),
  ciudad = c("Madrid", "Barcelona", "Valencia", "Sevilla")
)

# Realizar el left join
resultado <- left_join(tabla_izq, tabla_der, by = "id")

```
:::

::: {.column width="40%"}
![](Input/left.png){.absolute}
:::
::::


## Limpieza de la base de datos `Data` 

<!-- Bloque 1-->

Cargamos la base de datos `Data` es su forma "cruda"

```{r}
library(DT)
load("Databases/data.RData")
# datatable(data, options = list(scrollX = TRUE, scrollY = "500px"))
datatable( data,
  options = list(
    columnDefs = list(
      list(width = '20px'   , targets = 0),
      list(width = '20px'   , targets = 1),  
      list(width = '20px'   , targets = 2),
      list(width = '20px'   , targets = 3),  
      list(width = '20px'   , targets = 4),  
      list(width = '20px'   , targets = 5),  
      list(width = '20px'   , targets = 6)   
    )
  )
)
```
::: { .callout-note title="Nota"}
Sientase libre de jugar con la tabla de valores. Note que hay renglones y casillas en blanco que corresponden a valores no especificados, **NA**. Note también que hay casillas del tipo **De 5 a 9 años**.
Nuestra labor será limpiar o eliminar estos renglones y casillas.
:::

## Limpieza de la base de datos `Data` 

<!-- Bloque 2-->

Ahora, asignemos nombres a las columnas de nuestra tabla de datos.

```{r}
library(DT)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
datatable(data, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 3-->

Filtremos los renglones de la tabla de datos `Data`, manteniendo solo aquellos de la columna **edo** que no tienen valores **NA** y asignemos esta tabla filtrada a una nueva tabla de datos `base_mx`

```{r}
library(DT)
library(tidyverse)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE)
datatable( base_mx,
  options = list(
    columnDefs = list(
      list(width = '20px'   , targets = 0),
      list(width = '20px'   , targets = 1),  
      list(width = '1px'    , targets = 2),
      list(width = '20px'   , targets = 3),  
      list(width = '20px'   , targets = 4),  
      list(width = '20px'   , targets = 5),  
      list(width = '20px'   , targets = 6)   
    )
  )
)
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 4-->

Seleccionemos todas las columnas, excepto **id** y **both**

```{r}
library(DT)
library(tidyverse)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both"))
datatable( base_mx,
  options = list(
    columnDefs = list(
      list(width = '20px'   , targets = 0),
      list(width = '20px'   , targets = 1),  
      list(width = '20px'    , targets = 2),
      list(width = '20px'   , targets = 3)  
    )
  )
)
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 5-->

Despues de aplicar `na.omit()` a **base_mx**, solo nos quedaremos con los renglones donde no hay valores **NA**.

```{r}
library(DT)
library(tidyverse)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both")) %>%
  na.omit() 
datatable( base_mx,
  options = list(
    columnDefs = list(
      list(width = '20px'   , targets = 0),
      list(width = '20px'   , targets = 1),  
      list(width = '20px'    , targets = 2),
      list(width = '20px'   , targets = 3) 
    )
  )
)
```
::: { .callout-note title="Nota"}
En la tabla, busque valores donde la variable age tome el valor "Total"
:::

## Limpieza de la base de datos `Data` 

<!-- Bloque 6-->

En este segundo `filter()` estamos eliminando los renglones donde:

-   el valor age es **Total**

-   la columna age contiene la palabra **De**

-   la columna age contiene la palabra **85 años**

```{r}
library(tidyverse)
library(stringr)
library(DT)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both")) %>%
  na.omit() %>%
  filter(
    age != "Total",
    !grepl("De", age),
    !grepl("85 años", age)
  )
datatable( base_mx,
  options = list(
    columnDefs = list(
      list(width = '20px'   , targets = 0),
      list(width = '20px'   , targets = 1),  
      list(width = '20px'   , targets = 2),
      list(width = '20px'   , targets = 3)
    )
  )
)
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 7-->
La función **mutate** es usada para modificar una columna existente o agregar una nueva. En nuestro caso, modificaremos nuestra columna **age** para extraer el valor numérico de todos los renglones.

```{r}
library(tidyverse)
library(stringr)
library(DT)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both")) %>%
  na.omit() %>%
  filter(
    age != "Total",
    !grepl("De", age),
    !grepl("85 años", age)
  ) %>%
  mutate(age = str_extract(age,"\\d+"))
datatable(base_mx, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 7-->
La función `gather()`nos ayudará a transformar las columnas **male** y **female** en filas, creando nuevas columnas sex y pob.
Por otro lado `type_convert()`se utiliza para convertir automáticamente las columnas de un data frame a los tipos de datos más apropiados según su contenido. En nuestro caso, la variable **age** pasará de **string** a **numeric**

```{r}
library(tidyverse)
library(stringr)
library(DT)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both")) %>%
  na.omit() %>%
  filter(
    age != "Total",
    !grepl("De", age),
    !grepl("85 años", age)
  ) %>%
  mutate(age = str_extract(age,"\\d+")) %>%
  gather(key = sex, value = pob, -age, -edo) %>% 
  type_convert()
datatable(base_mx, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Limpieza de la base de datos `Data` 

<!-- Bloque 8-->
Usaremos la función `mutate()` para crear una nueva columan **pop2**. Si **sex** toma el valor de **female** entonces **pop2** tomará el valor de **pop**; en otro caso, **pop2** tomará el valor de -**pop**
Finalmente guardaremos nuestra nueva tabla de datos `base_mx` en nuestra carpeta **output**

```{r}
library(tidyverse)
library(stringr)
library(DT)
load("Databases/data.RData")
names(data)<-
  c("id","edo","age","both","males","females")
base_mx <- data %>% 
  filter(is.na(edo) == FALSE) %>% 
  select(-c("id", "both")) %>%
  na.omit() %>%
  filter(
    age != "Total",
    !grepl("De", age),
    !grepl("85 años", age)
  ) %>%
  mutate(age = str_extract(age,"\\d+")) %>%
  gather(key = sex, value = pob, -age, -edo) %>% 
  type_convert() %>% 
  mutate(pob2 = ifelse(sex == "females", pob, -pob))
save(base_mx, file = "input/base_mx.RData")
datatable(base_mx, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 1-->
Para la gráfica de la piramide de población, tomaremos en cuenta la población total. Para esta labor, recordemos que deberemos omitir los valores **NA**.
```{r}

library(tidyverse)
library(DT)
base_mx <- base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE)
datatable(base_mx, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 2-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)
base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) 
```


## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 3-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)
base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
    geom_hline(yintercept = 0)
```

## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 4-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)
base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25, 1.25),
    breaks = seq(-1.25, 1.25, 0.25),
    labels = as.character(
      c(seq(1.25, 0, -0.25),seq(0.25, 1.25, 0.25)
      ))
  )
```
## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 5-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)
base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25, 1.25),
    breaks = seq(-1.25, 1.25, 0.25),
    labels = as.character(
      c(seq(1.25, 0, -0.25),seq(0.25, 1.25, 0.25)
      ))
  )+
  scale_x_continuous(
    limits = c(-1, 101), breaks = seq(0, 100, 5),
    labels = seq(0, 100, 5)
  )
```

## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 5-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)
base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25, 1.25),
    breaks = seq(-1.25, 1.25, 0.25),
    labels = as.character(
      c(seq(1.25, 0, -0.25),seq(0.25, 1.25, 0.25)
      ))
  )+
  scale_x_continuous(
    limits = c(-1, 101), breaks = seq(0, 100, 5),
    labels = seq(0, 100, 5)
  )+
  annotate(
    geom = "text", x = 95, y = -1, label = "Hombres",
    color = "black", size = 3
  ) +
  annotate(
    geom = "text", x = 95, y = 1, label = "Mujeres",
    color = "black", size = 3
  ) 
```



## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 6-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)

base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25, 1.25),
    breaks = seq(-1.25, 1.25, 0.25),
    labels = as.character(
      c(seq(1.25, 0, -0.25),
        seq(0.25, 1.25, 0.25)
      ))
  ) +
  scale_x_continuous(
    limits = c(-1, 101), breaks = seq(0, 100, 5),
    labels = seq(0, 100, 5)
  )+
  annotate(
    geom = "text", x = 95, y = -1, label = "Hombres",
    color = "black", size = 3
  ) +
  annotate(
    geom = "text", x = 95, y = 1, label = "Mujeres",
    color = "black", size = 3
  ) +
  theme_light()
```

## Pirámide de población con la tabla de datos `Base_mx` 
<!-- Bloque 7-->
```{r}
#| code-fold: true
#| echo: true
library(tidyverse)

base_mx %>%
  filter(edo == "Total", is.na(age) == FALSE) %>%
  ggplot() +
  geom_bar(aes(x = age, y = pob2/1000000, fill = age),
           stat = "identity",
           show.legend = F) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25, 1.25),
    breaks = seq(-1.25, 1.25, 0.25),
    labels = as.character(
      c(seq(1.25, 0, -0.25),
        seq(0.25, 1.25, 0.25)
      ))
  ) +
  scale_x_continuous(
    limits = c(-1, 101), breaks = seq(0, 100, 5),
    labels = seq(0, 100, 5)
  )+
  annotate(
    geom = "text", x = 95, y = -1, label = "Hombres",
    color = "black", size = 3
  ) +
  annotate(
    geom = "text", x = 95, y = 1, label = "Mujeres",
    color = "black", size = 3
  ) +
  theme_light() +
  scale_fill_viridis_c(option = "A", guide = guide_colorbar())+
  labs(y = "Población (millones)", x = "Edad", fill = "Edad")
```
## Ejercicio de práctica 1 
Escoja algún estado de la tabla de datos `base_mx` y determine su pirámide de población.

## Ejercicio de práctica 2  
Calcule la proporción de gente no especificada de población total para ambos sexos, hombres y mujeres.

* Para esto, use un `left_join` para unir dos tablas.

  - La tabla izquierda deberá contar con la población total **pob** para ambos sexos.
  
  - La tabla derecha deberá contar con la población total no especificada **pob_na** para ambos sexos.
  
* Calcule la proporción **rat** de la poblacion total no especificada en porcentaje.

```{r}
library(tidyverse)
library(DT)
load("Databases/base_mx.RData")
base_mx <- left_join(
  base_mx %>% 
    filter(edo == "Total", is.na(age) == F) %>% 
    group_by(sex) %>% 
    summarise(pob = sum(pob), .groups = "drop"),
  base_mx %>% 
    filter(edo== "Total", is.na(age) == T) %>% 
    select(sex, pob_na = pob),
  by = "sex") %>% 
  mutate(rat = 100 * pob_na / pob)
datatable(base_mx, options = list(scrollX = TRUE, scrollY = "500px"))
```





## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

![](Input/piramide1.png){.absolute top="150" left="100" width="1390"}

## `Fuentes de información en demografía` {auto-animate=true}

<!-- bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::
::: {.callout-tip  title="Prorateo de población no es especificada"}
El prorateo de la población no especificada es una técnica en el análisis demografico para distribuir o asignar de manera proporcional una poblacion no especificada a la población determinada por una categoría.
:::


::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$N^*_x = N_x + N_{ne} \frac{N_x}{\sum_{x=0}^w N_x}$
:::



## `Fuentes de información en demografía` {auto-animate=true}

<!-- bloque 2-->

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$N^*_x = N_x + N_{ne} \frac{N_x}{\sum_{x=0}^w N_x}$
:::

::: {.callout-note  title="Donde:"}
$N^*_x$ es la nueva población total ajustada a la población no especificada de edad x

$N_x$  total de la población de edad x

$N_{ne}$ total de la población no especificada.

$\frac{N_x}{\sum_{x=0}^w N_x}$ es la proporcion del total de la poblacion de edad x, $N_x$, con respectoa la población total. 
:::

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 1-->
Tabla izquierda
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("input/base_mx.RData")
tabla_izq <- base_mx %>% 
    filter(edo == "Total")
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 2-->
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-  base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob))
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 3-->
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) 
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 4-->
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 5-->
Tabla derecha
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
tabla_der <- base_mx %>% 
    filter(edo == "Total", is.na(age) == T)
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```
## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 6-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
tabla_der <- base_mx %>% 
    filter(edo == "Total", is.na(age) == T) %>% 
    select(sex, pob_na = pob)
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 7-->

Tabla de datos prorateada `base_mx_pror`
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
tabla_der <- base_mx %>% 
    filter(edo == "Total", is.na(age) == T) %>% 
    select(sex, pob_na = pob)
base_mx_pror <-  left_join(tabla_izq,tabla_der,by = "sex")
datatable(base_mx_pror, options = list(scrollX = TRUE, scrollY = "500px"))
```

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 8-->

Recordemos la formula para la población final, $N^*_x$, para la variable **pop_fin**.
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
tabla_der <- base_mx %>% 
    filter(edo == "Total", is.na(age) == T) %>% 
    select(sex, pob_na = pob)
base_mx_pror <-  left_join(tabla_izq,tabla_der,by = "sex")
base_mx_pror <-  base_mx_pror %>% 
                    mutate(pob_fin = pob + pob_na * prop)
datatable(base_mx_pror, options = list(scrollX = TRUE, scrollY = "500px"))
```
::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$N^*_x = N_x + N_{ne} \frac{N_x}{\sum_{x=0}^w N_x}$
:::

## Prorateo de la tabla de datos `base_mx` 
<!-- Bloque 9-->
Resultado final para la tabla de datos `base_mx_pror`
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <-   base_mx %>% 
    filter(edo == "Total") %>% 
    group_by(sex) %>% 
    mutate(prop = pob / sum(pob)) %>% 
    filter(is.na(age) == F) %>%
    ungroup()
tabla_der <- base_mx %>% 
    filter(edo == "Total", is.na(age) == T) %>% 
    select(sex, pob_na = pob)
base_mx_pror <-  left_join(tabla_izq,tabla_der,by = "sex")
base_mx_pror <-  base_mx_pror %>% 
                    mutate(pob_fin = pob + pob_na * prop) %>% 
                    select(age, sex, pob = pob_fin)
datatable(base_mx_pror, options = list(scrollX = TRUE, scrollY = "500px"))
```


## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

::: {.callout-note .centered-callout title="Índice de Whipple (preferencia por dígitos 0 y 5)"}
$$
\begin{aligned}
W = 5\frac{N_{25}+N_{30}+N_{35}+...+N_{55}+N_{60}}{N_{23}+N_{24}+N_{25}+...+N_{55}+N_{62}}
\end{aligned}
$$ $W\in[1,5]$ donde 1 indica no prefencia de dígitos y 5 una alta preferencia.
:::


## `Fuentes de información en demografía`  
<!--Bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::
Tabla izquierda
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
    filter(
      age %in% c(25:60),
      age %% 10 == 0 | age %% 10 == 5
    )
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 2-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)

tabla_izq <- base_mx_pror %>% 
    filter(
      age %in% c(25:60),
      age %% 10 == 0 | age %% 10 == 5
    ) %>% 
    group_by(sex) %>% 
    summarise(pob_num = sum(pob), .groups = "drop")
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 3-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::
Tabla derecha
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)

tabla_der <- base_mx_pror %>% 
    filter(age %in% c(23:62))
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!-- Bloque 4-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)

tabla_der <-base_mx_pror %>% 
    filter(age %in% c(23:62)) %>% 
    group_by(sex) %>% 
    summarise(pob_den = sum(pob), ,groups = "drop")
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!-- Bloque 5-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::
Juntando **tabla_izq** y **tabla_der**
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <- base_mx_pror %>% 
    filter(
      age %in% c(25:60),
      age %% 10 == 0 | age %% 10 == 5
    ) %>% 
    group_by(sex) %>% 
    summarise(pob_num = sum(pob), .groups = "drop")
tabla_der <-base_mx_pror %>% 
    filter(age %in% c(23:62)) %>% 
    group_by(sex) %>% 
    summarise(pob_den = sum(pob), ,groups = "drop")
tabla <- left_join(tabla_izq,tabla_der,by="sex")
datatable(tabla, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!-- Bloque 6-->
::: {style="font-size: 1.2em; color: gray; margin-top: 10px;"}
 Índice de Wipple, usando la tabla de datos `base_mx_pror`
:::
Aqui mostramos el resultado del calculo del Índice de Wipple **W**
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
tabla_izq <- base_mx_pror %>% 
    filter(
      age %in% c(25:60),
      age %% 10 == 0 | age %% 10 == 5
    ) %>% 
    group_by(sex) %>% 
    summarise(pob_num = sum(pob), .groups = "drop")
tabla_der <-base_mx_pror %>% 
    filter(age %in% c(23:62)) %>% 
    group_by(sex) %>% 
    summarise(pob_den = sum(pob), ,groups = "drop")
tabla <- left_join(tabla_izq,tabla_der,by="sex") %>% 
  mutate(W = 5 * pob_num / pob_den)
datatable(tabla, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía`  
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

::: {.callout-tip title="Índice de Myers"}
Myers (1940) desarrolló un índice “combinado” para medir la preferencia de los 10 dígitos (Myers 1954). El método determina la proporción de la población cuya edad termina en cada dígito terminal (0-9), variando también la edad de inicio particular para cualquier grupo de edad de 10 años. Se basa en el principio de que, en ausencia de redondeo de edades, la población agregada en cada dígito terminal 0-9 debería representar aproximadamente el 10 por ciento de la población total. Su valor oscila entre 0 (no concentración de edades) a 90 (total concentración en una edad)
:::

## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

::: {.callout-tip tittle="Índice de Myers"}
El método implica 5 pasos principales (Siegel Jacob y Swanson David 2004):

-   Sumar las poblaciones que terminan en cada dígito sobre todo el rango, comenzando con el límite inferior del rango (por ejemplo, 10,20,30,...,80; 11,21,31,...,81).

-   Determinar la suma excluyendo la primera población en cada grupo del paso 1 (por ejemplo, 20,30,...,80; 21,31,...,81).

-   Ponderar las sumas de los pasos 1 y 2 y sumar los resultados para obtener una población combinada (por ejemplo, pesos 1 y 9 para el d ́ıgito 0; pesos 2 y 8 para el dígito 1).

-   Convertir la distribución del paso 3 en porcentajes.

-   Tomar la mitad de la suma de las desviaciones absolutas de cada porcentaje en el paso 4.
:::

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!-- Bloque 1-->
Tabla izquierda
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80))
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!-- Bloque 2-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <-base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10)
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 3-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop")
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 4-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop") %>% 
  mutate(
    weights  = c(1:10),
    tot_pop1 = step1*weights)
datatable(tabla_izq, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 5-->
Tabla derecha
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_der <-  base_mx_pror %>% 
  filter(age %in% c(10:80)) 
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 6-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10)
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 7-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_der <-base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) 
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 8-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") 
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 9-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") %>% 
  mutate (
    weights = c(9:0),
    tot_pop2 = step2*weights)
datatable(tabla_der, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 9-->
Tabla de datos **myers_tab**, juntando **tabla_izq** y **tabla_der**
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop") %>% 
  mutate(
    weights  = c(1:10),
    tot_pop1 = step1*weights)
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") %>% 
  mutate (
    weights = c(9:0),
    tot_pop2 = step2*weights)
myers_tab <- left_join(tabla_izq,tabla_der,by = "digit")
datatable(myers_tab, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 9-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop") %>% 
  mutate(
    weights  = c(1:10),
    tot_pop1 = step1*weights)
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") %>% 
  mutate (
    weights = c(9:0),
    tot_pop2 = step2*weights)
myers_tab <- left_join(tabla_izq,tabla_der,by = "digit")  %>% 
  select(digit,tot_pop1,tot_pop2)
datatable(myers_tab, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 10-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop") %>% 
  mutate(
    weights  = c(1:10),
    tot_pop1 = step1*weights)
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") %>% 
  mutate (
    weights = c(9:0),
    tot_pop2 = step2*weights)
myers_tab <- left_join(tabla_izq,tabla_der,by = "digit")  %>% 
  select(digit,tot_pop1,tot_pop2) %>% 
  mutate(blended = tot_pop1 + tot_pop2,
         blend_perc = 100*blended/sum(blended),
         deviat = abs(blend_perc-10 ))
datatable(myers_tab, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Índice de Myers con la tabla de datos `base_mx_pror`
:::
<!--Bloque 10-->

```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
tabla_izq <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  group_by(digit) %>% 
  summarise(step1 = sum(pob), .groups = "drop") %>% 
  mutate(
    weights  = c(1:10),
    tot_pop1 = step1*weights)
tabla_der <- base_mx_pror %>% 
  filter(age %in% c(10:80)) %>% 
  mutate(digit = age %% 10) %>% 
  filter(!age %in% c(10:19)) %>% 
  group_by(digit) %>% 
  summarise(step2 = sum(pob), .groups = "drop") %>% 
  mutate (
    weights = c(9:0),
    tot_pop2 = step2*weights)
myers_tab <- left_join(tabla_izq,tabla_der,by = "digit")  %>% 
  select(digit,tot_pop1,tot_pop2) %>% 
  mutate(blended = tot_pop1 + tot_pop2,
         blend_perc = 100*blended/sum(blended),
         deviat = abs(blend_perc-10 ))
myers_tab <-myers_tab %>% 
  summarise(myers = sum(deviat)/2)
datatable(myers_tab, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` {background-image=Background/bim1.png}

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Evaluación
:::

::: {.callout-tip .centered-callout tittle="Otros indicadores"}
-   Bachi 1951
-   Noumbissi 1992
-   Spoorenberg 2007
-   Coale-Li 1991
-   Jdanov 2008
:::

## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Corrección
:::

-   Agrupar por edades quinquenales
-   Utilizar algún método de graduación ( degradación en edades simples)

## `Fuentes de información en demografía` 
<!--Bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Agrupación por edades quinquenales con la tabla de datos `base_mx_pror`
:::
Definamos la secuencia de límites para las edades quinquenales.
```{r}
#| echo: true
#| code-fold: true
bins <- seq(0,max(base_mx_pror$age)+5,by = 5)
bins
```

## `Fuentes de información en demografía` 
<!--Bloque 2-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Agrupación por edades quinquenales con la tabla de datos `base_mx_pror`
:::
Definamos la secuencia de límites para las edades quinquenales.
```{r}
#| echo: true
#| code-fold: true
bins   <- seq(0,max(base_mx_pror$age)+5,by = 5)
labels <- paste(bins[-length(bins)],
                bins[-1]-1,
                sep="-")
labels
```

## `Fuentes de información en demografía` 
<!--Bloque 3-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Agrupación por edades quinquenales con la tabla de datos `base_mx_pror`
:::
Definamos la secuencia de límites para las edades quinquenales.
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
bins   <- seq(0,max(base_mx_pror$age)+5,by = 5)
labels <- paste(bins[-length(bins)],
                bins[-1]-1,
                sep="-")
base_mx_pror <- base_mx_pror %>% 
  mutate(age_group = cut(age,breaks = bins,
                         labels = labels, right = FALSE))
datatable(base_mx_pror, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 4-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Agrupación por edades quinquenales con la tabla de datos `base_mx_pror`
:::
Tabla de datos agrupados por edades quinquenales `base_mx_5`
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
bins   <- seq(0,max(base_mx_pror$age)+5,by = 5)
labels <- paste(bins[-length(bins)],
                bins[-1]-1,
                sep="-")
base_mx_pror <- base_mx_pror %>% 
  mutate(age_group = cut(age,breaks = bins,
                         labels = labels, right = FALSE))
base_mx_5 <- base_mx_pror %>% 
  group_by(sex,age_group) %>% 
  summarise(pob = sum(pob,na.rm=TRUE),
            .groups = "drop")
datatable(base_mx_5, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 5-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Agrupación por edades quinquenales con la tabla de datos `base_mx_pror`
:::
Tabla de datos agrupados por edades quinquenales `base_mx_5`
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
library(DT)
load("Databases/base_mx_pror.RData")
bins   <- seq(0,max(base_mx_pror$age)+5,by = 5)
labels <- paste(bins[-length(bins)],
                bins[-1]-1,
                sep="-")
base_mx_pror <- base_mx_pror %>% 
  mutate(age_group = cut(age,breaks = bins,
                         labels = labels, right = FALSE))
base_mx_5 <- base_mx_pror %>% 
  group_by(sex,age_group) %>% 
  summarise(pob = sum(pob,na.rm=TRUE),
            .groups = "drop") %>% 
  mutate(pob2 = ifelse(sex=="males",-pob,pob))
datatable(base_mx_5, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población por edades quinquenales con la tabla de datos `base_mx_5`
:::
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)
```

## `Fuentes de información en demografía` 
<!--Bloque 2-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población por edades quinquenales con la tabla de datos `base_mx_5`
:::
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)+
  coord_flip() +
  geom_hline(yintercept = 0)
```

## `Fuentes de información en demografía` 
<!--Bloque 3-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población por edades quinquenales con la tabla de datos `base_mx_5`
:::
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)+
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-6,6),breaks = seq(-6,6,1),
    labels = as.character(c(
      seq(6,0,-1),
      seq(1,6,1)
    ))
  )
```

## `Fuentes de información en demografía` 
<!--Bloque 4-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población por edades quinquenales con la tabla de datos `base_mx_5`
:::
```{r}
#| echo: true
#| code-fold: true
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)+
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-6,6),breaks = seq(-6,6,1),
    labels = as.character(c(
      seq(6,0,-1),
      seq(1,6,1)
    ))
  ) +
  annotate(
    geom = "text",x=20,y=-3,label="Hombres",size=3
  ) +
  annotate(
    geom = "text",x=20,y=3,label = "Mujeres",color = "black", size=3
  )
```

## `Fuentes de información en demografía` 
<!--Bloque 5-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población por edades quinquenales con la tabla de datos `base_mx_5`
:::
::: {.panel-tabset}

### Pirámide de población por edades quinquenales 

```{r}
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)+
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-6,6),breaks = seq(-6,6,1),
    labels = as.character(c(
      seq(6,0,-1),
      seq(1,6,1)
    ))
  ) +
  annotate(
    geom = "text",x=20,y=-3,label="Hombres",size=3
  ) +
  annotate(
    geom = "text",x=20,y=3,label = "Mujeres",color = "black", size=3
  ) +
  theme_light()+
  scale_fill_viridis_d(option = "C") 
```

### Código 

```{.r}
library(tidyverse)
base_mx_5 %>% 
  ggplot() +
  geom_bar(aes(x=age_group,y=pob2/1000000,fill=age_group),
           stat = "identity",
           show.legend = F)+
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-6,6),breaks = seq(-6,6,1),
    labels = as.character(c(
      seq(6,0,-1),
      seq(1,6,1)
    ))
  ) +
  annotate(
    geom = "text",x=20,y=-3,label="Hombres",size=3
  ) +
  annotate(
    geom = "text",x=20,y=3,label = "Mujeres",color = "black", size=3
  ) +
  theme_light()+
  scale_fill_viridis_d(option = "C") 
```

:::




## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Corrección
:::

::: {.callout-tip .centered-callout tittle="Métodos de graduación"}
-   Sprague 1880
-   Beers 1945
-   Spline monótono (Fritsch and Carlson 1980)\
-   PCLM (Rizzi, Gampe and Eilers 2015)
:::

## `Fuentes de información en demografía` 
<!--Bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Tabla de datos desagregados o suavizados de la tabla de datos `base_mx_5`
:::
La función `pclm()` se emplea para aplicar el método PCLM (Penalized Composite Link Model), que sirve para 
desagregar o suavizar datos agrupados. Este método es común en análisis demográficos, como la desagregación 
de datos de población o mortalidad que están agrupados por rangos de edad.

::: {.panel-tabset}

### Mujeres

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5M <- base_mx_5 %>% 
  filter(sex=="females")
datatable(base_mx_5M, options = list(scrollX = TRUE, scrollY = "500px"))
```

### Hombre

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5H <- base_mx_5 %>% 
  filter(sex=="males")
datatable(base_mx_5H, options = list(scrollX = TRUE, scrollY = "500px"))
```

:::

## `Fuentes de información en demografía` 
<!--Bloque 2-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Tabla de datos desagregados o suavizados de la tabla de datos `base_mx_5`
:::

::: {.panel-tabset}

### Mujeres: datos desagregados

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5M <- base_mx_5 %>% 
  filter(sex=="females")
base_mx_1_M <- pclm(x=bins[-length(bins)],
                    base_mx_5M$pob, nlast = 10) 
base_mx_1_M$fitted
```

### Hombre: datos desagregados

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5H <- base_mx_5 %>% 
  filter(sex=="males")
base_mx_1_H <- pclm(x=bins[-length(bins)],
                    base_mx_5H$pob, nlast = 10) 
base_mx_1_H$fitted
```

:::

## `Fuentes de información en demografía` 
<!--Bloque 3-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Tabla de datos desagregados o suavizados de la tabla de datos `base_mx_5`
:::

La función `enframe()` transforma el vector de poblaciones desagregadas o suavizadas (`base_mx_1_H$fitted` y `base_mx_1_H$fitted`) en un data 
frame con tres columnas:

	•	age: Una columna con los valores de 0 a 109, que representa las edades desagregadas.
	
	•	sex: Una columna que indica que todos los datos corresponden a mujeres y hombres.
	
	•	pob: Los valores de la población desagregada o suavizada por edad.

::: {.panel-tabset}

### Mujeres

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5M <- base_mx_5 %>% 
  filter(sex=="females")
base_mx_1_M <- pclm(x=bins[-length(bins)],
                    base_mx_5M$pob, nlast = 10) 
tabla_M  <- enframe(base_mx_1_M$fitted,
          name="age",value = "pob") %>% 
    mutate(age=c(0:109),sex="females",
           .before = pob)
datatable(tabla_M, options = list(scrollX = TRUE, scrollY = "500px"))
```

### Hombre

```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
load("Databases/base_mx_5.RData")
base_mx_5H <- base_mx_5 %>% 
  filter(sex=="males")
base_mx_1_H <- pclm(x=bins[-length(bins)],
                    base_mx_5H$pob, nlast = 10) 
tabla_H <- enframe(base_mx_1_H$fitted,
          name="age",value = "pob") %>% 
    mutate(age=c(0:109),sex="males",
           .before = pob)
datatable(tabla_H, options = list(scrollX = TRUE, scrollY = "500px"))
```
:::


## `Fuentes de información en demografía` 
<!--Bloque 4-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Tabla de datos desagregados o suavizados de la tabla de datos `base_mx_5`
:::
Juntamos ambos `Data.Frames` para crear una nueva tabla de datos llamada `base_mx_1`, que contendran los datos desagregados.
```{r}
#| echo: true
#| code-fold: true
library(ungroup)
library(tidyverse)
library(DT)
base_mx_5H <- base_mx_5 %>% 
  filter(sex=="males")

base_mx_5M <- base_mx_5 %>% 
  filter(sex=="females")

base_mx_1_H <- pclm(x=bins[-length(bins)],
                    base_mx_5H$pob, nlast = 10) 

base_mx_1_M <- pclm(x=bins[-length(bins)],
                    base_mx_5M$pob, nlast = 10) 

base_mx_1 <- rbind(
  enframe(base_mx_1_H$fitted,
          name="age",value = "pob") %>% 
    mutate(age=c(0:109),sex="males",
           .before = pob)
  ,
  enframe(base_mx_1_M$fitted,
          name="age",value = "pob") %>% 
    mutate(age=c(0:109),sex="females",
           .before = pob))  %>% 
  mutate(pob2 = ifelse(sex=="males",-pob,pob))
datatable(base_mx_1, options = list(scrollX = TRUE, scrollY = "500px"))
```

## `Fuentes de información en demografía` 
<!--Bloque 1-->
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Pirámide de población con los datos desagregados o suavizados de la tabla de datos `base_mx_1`
:::

::: {.panel-tabset}

### Pirámide poblacional
```{r}
library(tidyverse)
load("Databases/base_mx_1.RData")

base_mx_1 %>% 
  ggplot() +
  geom_bar(aes(x=age,y=pob2/1000000,fill=age),
           stat = "identity",
           show.legend = F
  ) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25,1.25),breaks = seq(-1.25,1.25,0.25),
    labels = as.character(c(
      seq(1.25,0,-0.25),
      seq(0.25,1.25,0.25)
    ))
  ) +
  scale_x_continuous(
    limits = c(-1,110),
    breaks = seq(0,110,5),
    labels = seq(0,110,5)
  ) +
  annotate(
    geom = "text",x=95,y=-1,label="Hombres",size=3
  ) +
  annotate(
    geom = "text",x=95,y=1,label = "Mujeres",color = "black", size=3
  )+
  theme_light() +
  scale_fill_viridis_c(option = "A", guide = guide_colorbar()) 
```

### Código 

```{.r}
library(tidyverse)
load("Databases/base_mx_1.RData")

base_mx_1 %>% 
  ggplot() +
  geom_bar(aes(x=age,y=pob2/1000000,fill=age),
           stat = "identity",
           show.legend = F
  ) +
  coord_flip() +
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    limits = c(-1.25,1.25),breaks = seq(-1.25,1.25,0.25),
    labels = as.character(c(
      seq(1.25,0,-0.25),
      seq(0.25,1.25,0.25)
    ))
  ) +
  scale_x_continuous(
    limits = c(-1,110),
    breaks = seq(0,110,5),
    labels = seq(0,110,5)
  ) +
  annotate(
    geom = "text",x=95,y=-1,label="Hombres",size=3
  ) +
  annotate(
    geom = "text",x=95,y=1,label = "Mujeres",color = "black", size=3
  )+
  theme_light() +
  scale_fill_viridis_c(option = "A", guide = guide_colorbar()) 
```

:::










## `Fuentes de información en demografía` 

::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Corrección
:::

![](Input/piramide3.png){.absolute top="150" left="100" width="1390"}

## `Fuentes de información en demografía` 

::: {.callout-tip  tittle="Métodos de graduación"}
-   Registro tardío
-   Mala declaración de edad.
-   Sesgos
:::

## `Fuentes de información en demografía` 

::: {.callout-tip .centered-callout tittle="Problemas en las escuestas"}
-   Error de muestreo
-   Representatividad
:::

## `Conceptos básicos` 

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
-   $proporción = \frac{Núm. \,de\, elementos\, de \,un\, subconjunto}{Núm.\, de\, elementos\, del\, total}$
-   $razón = \frac{Núm. \,de\, elementos\, de\, un\, subconjunto}{Núm. \,de\, elementos\, de \,otro \,subconjunto}$
-   $tasa  = \frac{Núm.\, de \,veces\, que\, ocurre \,un\, evento}{Años-persona\, de\, exposición\, al\, riesgo}$
-   $probabilidad  = \frac{Núm.\, de\, veces \,que \,ocurre\, un\, evento}{Núm.\, de \,casos\, igualmente \,factibles}$
:::


## `Tasas de periodo y años-persona` 

::: {style="text-align: center; font-size: 1.5em; margin-top:200px;"}
$tasa[0,T] = \frac{Núm.\, de\, veces\, que\, ocurre\, un \, evento\, entre\,0 \,y\,T}{Años-persona\, vividos\, por\, la \,población \,entre\,0\,y\,T}$
:::

## `Tasas de periodo y años-persona` 

![](Input/años-persona%20.png){.absolute top="150" left="100" width="1390"}

## `Tasas de periodo y años-persona` {auto-animate="true"}

::: {style="text-align: center; font-size: 2em; margin-top:100px;"}
$AP[t_1,t_2]= \sum_{i=t_1}^{t_2}N_i\Delta_i$
:::

::: {style="text-align: center; font-size: 2em; margin-top:250px;"}
$AP[t_1,t_2]= \sum_{i=t_1}^{t_2}N_i\Delta_i$
:::

::: {style="text-align: center; font-size: 2em; margin-top: 150px;"}
$AP[t_1,t_2]= \int_{t_1}^{t_2}N(t)dt$
:::

## `Definición formal de la derivada`
Decimos que una función, $f:Dom(f)\to \mathbb{R}$, es derivable en un punto $x$ si y solo si:

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$\lim_{h\to 0}\frac{f(x+h)-f(x)}{h}$
:::
existe.

Decimos que una función, $f:Dom(f)\to \mathbb{R}$, es derivable en todo su **dominio** si y solo si para todo $x\in Dom(f)$, f es derivable en $x$

## `Definición formal de la derivada`
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Animación gráfica de la derivada en un punto $x$
:::
![](Input/derivate.gif){.absolute top="50" left="50" width="1500"}


## `Tasas de crecimiento` {auto-animate="true"}
::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

## `Tasas de crecimiento` {auto-animate="true"}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 150px;"}
$r(t)=\color{red}{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
-   Pues se tiene que los años-persona $AP[t_1,t_2] = N(t)(t_2 - t_1)= N(t)\Delta t$.
-   Además, al buscar el cambio instantaneo, hacemos $t_1 \to t_2$, que se entiende como $t_1$ toma valores cada vez parecidos a $t_2$. En este sentido $\Delta t=t_2-t_1 \to 0$, que se entiende que el cambio entre el tiempo $t_1$ y $t_2$ tiende a 0, toma valores cada vez mas cercanos a cero.
:::

## `Tasas de crecimiento` {auto-animate="true"}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 150px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\lim_{\Delta t \to 0}\color{red}{\frac{\Delta N(t)}{\Delta t}/\frac{N(t)}{1}}$
:::

::: { .callout-warning title="El diablo esta en los detalles"}
Por la ley del "Sándwich". Es decir, para $a,b,c,d$ números reales,tenemos que $\frac{a}{b}}/\frac{c}{d} = \frac{a.d}{b.c}$
:::

## `Tasas de crecimiento` {auto-animate="true"}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\color{red}{\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
-   Por la ley de cocientes para los límites $\lim_{t\to           a}\frac{f(t)}{g(t)}=\frac{\lim_{t\to a}f(t)}{\lim_{t\to        a}g(t)}$
-   En nuestro caso especifico tenemos que $f(t)=\frac{\Delta N(t)}{\Delta t}$ y $g(t)=\frac{N(t)}{1}$
-   Notemos que $\lim_{\Delta \to 0}N(t)= N(t)$, pues $N(t)$ no depende de $\Delta t$, es decir, no depende del cambio entre $t_1$ y $t_2$.
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\color{red}{\frac{N^{'}(t)}{N(t)}}$
:::

::: { .callout-warning title="El diablo esta en los detalles"}
Por la definición de la derivada en un punto $t$: $N^{'}(t)=\frac{dN(t)}{dt}=\lim_{\Delta t \to 0}\frac{N(t_2)-N(t_1)}{t_2-t_1}=\lim_{\Delta t\to 0}\frac{\Delta N(t)}{\Delta t}$
:::

## `Tasas de crecimiento` {auto-animate="true'}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\color{red}{\frac{d\, ln(N(t))}{dt}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Por la derivada de $In(t)$ en un punto $t$: $\frac{d}{dt}ln(t)=\frac{1}{t}$.

\par

Y más en general, para cualquier función derivable $f(t)$ $\frac{d}{dt}ln[f(t)]=\frac{f^{'}(t)}{f(t)}$
:::

## `Tasas de crecimiento` {auto-animate="true"}

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d\, ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1.5em; margin-top:50px;"}
$\color{red}{\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}ln(t)dt}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Integrando por ambos lados de la ecuación sobre el intervalo $(t_1,t_2)$
:::

## `Tasas de crecimiento` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top: 150px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d \,ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1m; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}ln(t)=\color{red}{ln[N(t_2)]-ln[N(t1)]}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Por teorema fundamental del cálculo. En esencia, lo que nos dice el teorema, es que la derivada y la integral son operaciones inversas.
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d \,ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}ln(t)dt=ln[N(t_2)]-ln[N(t1)]=\color{red}{ln[\frac{N(t_2)}{N(t_1)}]}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Por leyes de los logaritmos. Para cualquiera números $a$ y $b$ se satisface $ln(\frac{a}{b})=ln(a)-ln(b)$
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top: 90px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d \,ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}ln(t)dt=ln[N(t_2)]-ln[N(t1)]=\color{red}{ln \left[ \frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\color{red}{e^{\int_{t_1}^{t_2}r(t)dt}=e^{ln\left[\frac{N(t_2)}{N(t_1)}\right]}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Aplicando la exponencial a ambos lados de la ecuación $e^x$
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top: 50px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d \,ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}in(t)dt=ln[N(t_2)]-ln[N(t1)]=\color{red}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$e^{\int_{t_1}^{t_2}r(t)dt}=\color{red}{\frac{N(t_2)}{N(t_1)}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Esto es, pues, la exponencial, $e^x$, y el logaritmo natural, $In(x)$, son operaciones inversas Esto es $e^{In(x)}=x$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Ojo: $In(e^x)=x$ si y solo si $x>0$
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top: 50px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d \,ln(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}ln(t)dt=ln[N(t_2)]-ln[N(t1)]=\color{red}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$e^{\int_{t_1}^{t_2}r(t)dt}=\frac{N(t_2)}{N(t_1)}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$N(t_2)= \color{red}{N(t_1)e^{\int_{t_1}^{t_2}r(t)dt}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
Despejando $N(t_2)$
:::

## `Tasas de crecimiento` {auto-animate="true" background-image=Background/bim1.png}

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$r(t_1,t_2)=\frac{N(t_2)-N(t_1)}{AP[t_1,t_2]}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top: 50px;"}
$r(t)=\lim_{\Delta t \to 0}\frac{\Delta N(t)}{N(t)\Delta t}=\frac{\lim_{\Delta t \to 0}\frac{\Delta N(t)}{\Delta t}}{N(t)}=\frac{N^{'}(t)}{N(t)}=\frac{d In(N(t))}{dt}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$\int_{t_1}^{t_2}r(t)dt=\int_{t_1}^{t_2}\frac{d}{dt}In(t)dt=ln[N(t_2)]-In[N(t1)]=In\left[\frac{N(t_2)}{N(t_1)}\right]$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$e^{\int_{t_1}^{t_2}r(t)dt}=\frac{N(t_2)}{N(t_1)}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$N(t_2)= N(t_1)e^{\int_{t_1}^{t_2}r(t)dt}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\color{red}{\overline{r}(t_1,t_2)=\frac{\int_{t_1}^{t_2}r(t)dt}{t_2-t_1}=\frac{ln\left[\frac{N(t_1)}{N(t_2)}\right]}{t_2-t_1}}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
-   Si $r(t)=\overline{r}(t_1,t_2)$, entonces $r(t)$ ya no depende de $t$ y es ahora una constante.
-   Por lo tanto $\int_{t_1}^{t_2}\overline{r}(t_1,t_2)dt=\overline{r}(t_1,t_2)\int_{t_1}^{t_2}dt$
-   Por lo tanto $\int_{t_1}^{t_2}\overline{r}(t_1,t_2)dt=\overline{r}(t_1,t_2)\int_{t_1}^{t_2}dt=\overline{r}(t_1,t_2)(t_2-t_1)$
:::

## `Series de Maclaurin`

Una serie de Maclaurin para una función  $f(x)$  es una representación en forma de una suma infinita de potencias de  $x$. Para $f$ derivable en $0$, la serie se define como:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$f(x) = f(0) + \frac{f'(0)}{1!}x + \frac{f''(0)}{2!}x^2 + \frac{f^{(3)}(0)}{3!}x^3 + \cdots$
:::

O en notación de suma infinita:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(0)}{n!} x^n$
:::

El ejemplo particular que nos interesa es la serie de Maclaurin del logaritmo natural:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\ln(1+x) = \sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n = x - \frac{x^2}{2} + \frac{x^3}{3} - \cdots, \quad |x| < 1$
:::
Asi tenemos que:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\ln(1+x) \approx x$ para $n=1$
:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\color{red}{=\frac{N(t_2)-N(t_1)}{\frac{In\left[\frac{N(t_2)}{N(t_1)}\right]}{t_2-t_1}}}$
:::

::: { .callout-warning title="El diablo esta en los detalles"}
Por lo el resultado anterior cuando 
$r(t)=\overline{r}(t_1,t_2)=\frac{ln\left[\frac{N(t_2)}{N(t_1)}\right]}{t_2-t_1}$
:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1)}{\frac{ln[\frac{N(t_2)}{N(t_1)}]}{t_2-t_1}}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\color{red}{=\frac{N(t_2)-N(t_1).[t_2-t_1]}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}}$
:::

:::{ .callout-warning title="El diablo esta en los detalles"}
Por la ley del "Sandwich"
:::

## `Aproximación a los AP` {auto-animate="true"}

:::{ .callout-warning title="El diablo esta en los detalles"}
En este apartado aproximaremos $ln(\frac{N(t_2)}{N(t_1)})$

* $N(t_2)=N(t_2)+0=N(t_2)+[N(t_1)-N(t_1)]=N(t_1)+[N(t_2)-N(t_1)]$

* $\frac{N(t_2)}{N(t_1)}=1+\frac{N(t_2)-N(t_1)}{N(t_1)}$ dividiendo sobre $N(t_1)$

* Sea $x=\frac{N(t_2)-N(t_1)}{N(t_1)}$

* Para $t_1\to t_2$ tenemos que $N(t_1)\to N(t_2)$

* Lo que implica que cuando $t_1\to t_2$ se tiene que $N(t_1)\approx N(t_2)$

* Por lo tanto $|x| \leq \left|\frac{N(t_2)-N(t_1)}{N(t_1)}\right|\leq \left|\frac{1}{N(t_1)}\right| = \frac{1}{N(t_1)} < 1$

* Se cumplen las hipótesis para aproximar $ln(1+x)$ por su serie de Maclaurin

* Asi tenemos que $ln\left(\frac{N(t_2)}{N(t_1)}\right)=ln\left(1+\frac{N(t_2)-N(t_!)}{N(1)}\right)\approx \frac{N(t_2)-N(t_!)}{N(t_1)}$

:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1)}{\frac{ln[\frac{N(t_2)}{N(t_1)}]}{t_2-t_1}}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1).[t_2-t_1]}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1).[t_2-t_1]}{\color{red}{\frac{N(t_2)-N(t_1)}{N(t_1)}}}$
:::

:::{ .callout-warning title="El diablo esta en los detalles"}
Por el apartado anterior 
:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1)}{\frac{ln[\frac{N(t_2)}{N(t_1)}]}{t_2-t_1}}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1).[t_2-t_1]}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1).[t_2-t_1]}{{\frac{N(t_2)-N(t_1)}{N(t_1)}}}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\color{red}{N(t_1)}.[t_2-t_1]$
:::

:::{ .callout-warning title="El diablo esta en los detalles"}
Pues
$\frac{N(t_2)-N(t_1).[t_2-t_1]}{{\frac{N(t_2)-N(t_1)}{N(t_1)}}} = \frac{N(t_2)-N(t_1)}{N(t_2)-N(t_1)}.N(t_1)[t_2-t_1]=N(t_1)[t_2-t_1]$
:::

## `Aproximación a los AP` {auto-animate="true"}

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1)}{\overline{r}(t_1,t_2)}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1)}{\frac{ln[\frac{N(t_2)}{N(t_1)}]}{t_2-t_1}}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$=\frac{N(t_2)-N(t_1).[t_2-t_1]}{ln\left[\frac{N(t_2)}{N(t_1)}\right]}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$AP[t_1,t_2]=\frac{N(t_2)-N(t_1).[t_2-t_1]}{{\frac{N(t_2)-N(t_1)}{N(t_1)}}}$
:::

::: {style="text-align: center; font-size: 0.5em; margin-top:50px;"}
$AP[t_1,t_2]=N(t_1).[t_2-t_1]$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$AP[t_1,t_2]=\color{red}{\hat{N}(t_1)}.[t_2-t_1]$ donde $\hat{N}(t_1)$ es la población a mitad de periodo entre $t_1$ y $t_2$
:::

:::{ .callout-warning title="El diablo esta en los detalles"}
Sabemos que: 

* $N(t_1)\leq \hat{N}(t_1)\leq N(t_2)$

* Cuando $t_1\to t_2$ tenemos que $N(t_1)\approx \hat{N}(t_1)\approx N(t_2)$

:::

## `Diagrama de Lexis` 

```{r,out.width='800%', out.height='900px'}
library(LexisPlotR)
lexis_grid(year_start = 1900, year_end = 1905, age_start = 0, age_end = 5)
```

## `Diagrama de Lexis` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Edad
:::
```{r,out.width='800%', out.height='900px'}
library(LexisPlotR)
lexis <- lexis_grid(year_start = 1900, year_end = 1905, age_start = 0, age_end = 5)
lexis_age(lg = lexis, age = 2)
```

## `Diagrama de Lexis` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Corte
:::
```{r,out.width='800%', out.height='900px'}
library(LexisPlotR)
lexis <- lexis_grid(year_start = 1900, year_end = 1905, age_start = 0, age_end = 5)
lexis_cohort(lg = lexis, cohort = 1898)
```


## `Diagrama de Lexis` 
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Periodo
:::
```{r,out.width='800%', out.height='900px'}
library(LexisPlotR)
lexis <- lexis_grid(year_start = 1900, year_end = 1905, age_start = 0, age_end = 5)
lexis_year(lg = lexis, year = 1903)
```



## `Diagrama de Lexis` 

![](Input/diagrama_de_lexis1.png){.absolute top="150" left="100" width="1390"}\

## `Diagrama de Lexis` {background-image=Background/bim1.png}

![](Input/diagrama_de_lexis2.png){.absolute top="150" left="100" width="1390"}

## `Diagrama de Lexis` 

![](Input/diagrama_de_lexis3.png){.absolute top="150" left="100" width="1390"}

## `Diagrama de Lexis` 
<!-- Bloque 0 -->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1900-01-01", "1900-01-01", "1901-01-01",    # zweiter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # dritter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # vierter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # fünfter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 1 -->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # dritter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # vierter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # fünfter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 2 -->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # vierter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # fünfter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 3-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # fünfter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```


## `Diagrama de Lexis`
<!-- Bloque 4-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1900-01-01", "1900-01-01", "1901-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 5-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1903-01-01", "1903-01-01", "1904-01-01",    # sechster polygon
                "1900-01-01", "1901-01-01", "1901-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 6-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1903-01-01", "1903-01-01", "1904-01-01",    # sechster polygon
                "1903-01-01", "1904-01-01", "1904-01-01",    # siebter 
                "1900-01-01", "1900-01-01", "1901-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 7-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1903-01-01", "1903-01-01", "1904-01-01",    # sechster polygon
                "1903-01-01", "1904-01-01", "1904-01-01",    # siebter 
                "1904-01-01", "1904-01-01", "1905-01-01",    # achter
                "1900-01-01", "1901-01-01", "1901-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 8-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1903-01-01", "1903-01-01", "1904-01-01",    # sechster polygon
                "1903-01-01", "1904-01-01", "1904-01-01",    # siebter 
                "1904-01-01", "1904-01-01", "1905-01-01",    # achter
                "1904-01-01", "1905-01-01", "1905-01-01",    # neunter
                "1900-01-01", "1900-01-01", "1901-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```

## `Diagrama de Lexis` 
<!-- Bloque 9-->
```{r}
#| echo: false

library(dplyr)
library(ggplot2)
library(Epi)



# Step 1: Stellen sie manuellen Lexis Gitternetzlinien beit horizontal, vertikal, and diagonal linienen

# Horizontal linien (constant ages over time)
horizontal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01", "1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01","1905-01-01")),
  y_start = c(0, 1, 2, 3, 4, 5),
  y_end   = c(0, 1, 2, 3, 4, 5)
)

# Vertikal linnien (constant years)
vertical_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1900-01-01","1900-01-01","1900-01-01","1900-01-01")),
  x_end   = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01", "1905-01-01"
                      ,"1904-01-01","1903-01-01","1902-01-01","1901-01-01")),
  y_start = c(0, 0, 0, 0, 0, 0,
              1, 2, 3, 4),
  y_end   = c(5, 5, 5, 5, 5, 5,
              5, 5, 5, 5)
)

# Diagonal liniel (cohorts aging over time)
diagonal_lines <- data.frame(
  x_start = as.Date(c("1900-01-01", "1901-01-01", "1902-01-01", "1903-01-01", "1904-01-01")),
  x_end   = as.Date(c("1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01", "1905-01-01")),
  y_start = c(0, 0, 0, 0, 0),
  y_end   = c(5, 4, 3, 2, 1)
)

# Step 2: Define the polygons with custom colors
polygons <- data.frame(
  group = c(1, 1, 1, 
            2, 2, 2,
            3, 3, 3,
            4, 4, 4,
            5, 5, 5,
            6, 6, 6,
            7, 7, 7,
            8, 8, 8,
            9, 9, 9,
           10, 10,10),  # Group defines which vertices belong to the same polygon
  x = as.Date(c("1900-01-01", "1901-01-01", "1901-01-01",    # erster polygon (orange)
                "1901-01-01", "1901-01-01", "1902-01-01",    # zweiter polygon
                "1901-01-01", "1902-01-01", "1902-01-01",    # dritter polygon
                "1902-01-01", "1902-01-01", "1903-01-01",    # vierter polygon
                "1902-01-01", "1903-01-01", "1903-01-01",    # fünfter polygon
                "1903-01-01", "1903-01-01", "1904-01-01",    # sechster polygon
                "1903-01-01", "1904-01-01", "1904-01-01",    # siebter 
                "1904-01-01", "1904-01-01", "1905-01-01",    # achter
                "1904-01-01", "1905-01-01", "1905-01-01",    # neunter
                "1905-01-01", "190-01-01", "1906-01-01")),  # zehnter
  y = c(0, 0, 1, # erster
        0, 1, 1, # zweiter
        1, 1, 2, # dritter
        1, 2, 2, # vierter
        2, 2, 3, # fünfter
        2, 3, 3, # sechter
        3, 3, 4, # siebter
        3, 4, 4, # achter
        4, 4, 5, # neunter
        4, 5, 5),  # zehnter
  
  fill_color <- c(
    "#8A2BE2", "#8A2BE2", "#8A2BE2", 
    "#008080", "#008080", "#008080",  # Purple and Teal
    "#FF69B4", "#FF69B4", "#FF69B4", 
    "#1E90FF", "#1E90FF", "#1E90FF",  # Pink and Blue
    "#FFD700", "#FFD700", "#FFD700", 
    "#228B22", "#228B22", "#228B22",  # Gold and Forest Green
    "#DC143C", "#DC143C", "#DC143C", 
    "#00FFFF", "#00FFFF", "#00FFFF",  # Crimson and Cyan
    "#FF7F50", "#FF7F50", "#FF7F50", 
    "#000080", "#000080", "#000080"  # Coral and Navy
  )
  
)

# Step 3: Plot the Lexis grid and the polygons
ggplot() +
  # Add horizontal lines
  geom_segment(data = horizontal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add vertical lines
  geom_segment(data = vertical_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add diagonal lines
  geom_segment(data = diagonal_lines, aes(x = x_start, y = y_start, xend = x_end, yend = y_end), color = "black") +
  
  # Add polygons with controlled colors
  geom_polygon(data = polygons, aes(x = x, y = y, group = group, fill = fill_color), alpha = 0.7) +
  
  scale_fill_identity() +  # Use the colors defined in the 'fill_color' column
  
  # Customize the theme to remove grid lines and borders
  theme_minimal() +
  theme(panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        panel.border = element_blank())+
  
  # Set axis limits (adjust as necessary)
  xlim(as.Date("1900-01-01"), as.Date("1910-01-01")) +  # x-axis limits
  ylim(0, 5)  # y-axis limits
```
## `Diagrama de Lexis-Probabilidades cohorte por edad` 

::: {style="text-align: center; font-size: 2em; margin-top:200px;"}
${}_1q_0^{\text{C1980}} = \frac{{}_1D_0^{\text{C1980}}}{B_0^{\text{C1980}}}$
:::

::: {style="text-align: center; font-size: 2em; margin-top:50px;"}
${}_5q_{25}^{\text{C1980}} = \frac{{}_5D_{25}^{\text{C1980}}}{{}_5N_{25}^{\text{C1980}}}$
:::

## `Tasa especificas por edad de periodo` 

::: {style="text-align: center; font-size: 2em; margin-top:200px;"}
${}_nM_x[t_1,t_2]=\frac{{}_nD_x[t_1,t_2]}{{}_nAP_x[t_1,t_2]}=\frac{{}_nD_x[t_1,t_2]}{(t_2-t_1){}_nN_x}$
:::

::: {.callout-tip title="Nota"}
Usualmente $t_2 - t_1 = n$
:::

## `Estandarización` 

::: {.callout-tip title="Recordando"}
::: {style="text-align: center; font-size: 2em; margin-top:100px;"}
1.  $tbm_{\text{Europa}}(2005,2010) = 11.3$
2.  $tbm_{\text{Africa}}(2005,2010) = 11.8$
3.  $tbm_{\text{Mundo}}(2005,2010) = 8.1$
4.  $tbm_{\text{Latam}}(2005,2010) = 5.8$
:::
:::

## `Estandarización` {auto-animate="true"}

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$\text{tbm}=\frac{D}{N}=\frac{\sum_{x=0}^\omega {}_nD_x}{N}$
:::

## `Estandarización` {auto-animate="true"}

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$\text{tbm}=\frac{D}{N}=\frac{\sum_{x=0}^\omega {}_nD_x}{N}$
:::

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$\hspace{3.5cm}= \sum_{x=0}^{\omega}\frac{{}_nD_x}{N}\frac{{}_nN_x}{{}_nN_x}$
:::

## `Estandarización` {auto-animate="true"}

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$\text{tbm}=\frac{D}{N}=\frac{\sum_{x=0}^\omega {}_nD_x}{N}$
:::

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$=\hspace{3.5cm}\sum_{x=0}^{\omega}\frac{{}_nD_x}{N}\frac{{}_nN_x}{{}_nN_x}$
:::

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$=\hspace{3.5cm} \sum_{x=0}^{\omega} \frac{{}_nD_x}{{}_nN_x} \frac{{}_nN_x}{N}$
:::

::: {style="text-align: center; font-size: 1.2em; margin-top:100px;"}
$=\hspace{3.5cm}\sum_{x=0}^{\omega} {}_nM_x \hspace{0.5cm} {}_nC_x$
:::

::: {.callout-note title="donde"}
::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\sum_{x=0}^{\omega} {}_nC_x = \frac{\sum_{x=0}^{\omega +} {}_nN_x}{N}=1$
:::
:::

## `Estandarización` {auto-animate="true"}

::: {.callout-note title="Tomando la ${}_nC_x de Europa$"}
::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$tbm^*=\sum_{x=0}^{\omega} {}_nM^{Africa}_x \hspace{0.5cm} {}_nC^{Europa}_x$
:::
:::

## `Estandarización` {auto-animate="true"}

::: {.callout-note title="Tomando la ${}_nC_x$ de Europa"}
::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$tbm^*=\sum_{x=0}^{\omega} {}_nM^{Africa}_x \hspace{0.5cm} {}_nC^{Europa}_x$
:::
:::

::: {.callout-note title="En general"}
::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$ASCDR^j= \sum_{x=0}^{\omega}  {}_nM_x^{j}\,{}_nC_x^S$
:::
:::

para $j=A,B$ y

::: {style="text-align: center; font-size: 1.5em; margin-top:50px;"}
${}_nC_x^S = \frac{{}_nC_x^A+{}_nC_x^B}{2}$
:::

## `Estandarización`
::: {style="font-size: 1.2em; color: gray; margin-top: -10px;"}
Limpieza de la base de datos `WPP2024 MORT F01 1 DEATHS SINGLE AGE BOTH_SEXES`
:::

```{r}
#| code-fold: true
library(DT)
load("Databases/base0_raw.RData")
base0 <- base0_raw
datatable(head(base0,1000), options = list(scrollX = TRUE, scrollY = "500px"))
```

## `La Tabla de Mortalidad` {auto-animate="true"}

::: {.callout-note title="Datos observados"}
${}_nN_x$ es la población a la mitad de año entre las edades $x$ y $x+n$

${}_nD_x$ son las defunciones totales que ocurridas entre las edades $x$ y $x+n$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nm_x = \frac{{}_nd_x}{{}_nL_x}\simeq \frac{{}_nD_x}{{}_nN_x}$
:::

## `La Tabla de Mortalidad` {auto-animate="true"}
::: {.callout-note title="Datos observados"}
${}_nN_x$ es la población a la mitad de año entre las edades $x$ y $x+n$

${}_nD_x$ son las defunciones totales que ocurridas entre las edades $x$ y $x+n$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nm_x = \frac{{}_nd_x}{{}_nL_x}\simeq \frac{{}_nD_x}{{}_nN_x}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nd_x = l_x-l_{x+n}=l_x\hspace{0.2cm}{}_nq_x$
:::

## `La Tabla de Mortalidad` {auto-animate="true"}

::: {.callout-note title="Datos observados"}
${}_nN_x$ es la población a la mitad de año entre las edades $x$ y $x+n$

${}_nD_x$ son las defunciones totales que ocurridas entre las edades $x$ y $x+n$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nm_x = \frac{{}_nd_x}{{}_nL_x}\simeq \frac{{}_nD_x}{{}_nN_x}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nd_x = l_x-l_{x+n}=l_x\hspace{0.2cm}{}_nq_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nq_x = \frac{{}_nd_x}{l_x}$
:::

## `La Tabla de Mortalidad` {auto-animate="true"}

::: {.callout-note title="Datos observados"}
${}_nN_x$ es la población a la mitad de año entre las edades $x$ y $x+n$

${}_nD_x$ son las defunciones totales que ocurridas entre las edades $x$ y $x+n$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nm_x = \frac{{}_nd_x}{{}_nL_x}\simeq \frac{{}_nD_x}{{}_nN_x}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nd_x = l_x-l_{x+n}=l_x\hspace{0.2cm}{}_nq_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nq_x = \frac{{}_nd_x}{l_x}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_{x+n}+{}_nA_x=nl_{x+n}+{}_na_x/,{}_nd_x$
:::

## `Tabla de Mortalidad` 

![](Input/tabla.png){fig-align="center"}

## `Método de Greville y Chiang para el cálculo de $L_x$` {background-image=Background/bim1.png}

<!-- Primer bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Segundo bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=\color{red}{nl_x-n{}_nd_x}+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {.callout-warning title="Ojo"}
Por **propiedad distributiva**, es decir, para cualesquiera $a,x,y$ números se satisface: $a*(x+y)=a*x+b*y$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Tercer bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=\color{red}{nl_x-n{}_nd_x}+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
**Despejando** $nl_x$. Asi pues:

-   ${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$

-   ${}_nl_x={}_nL_x+n{}_nd_x-{}_na_x\hspace{0.2cm}{}_nd_x$ despejando $nl_x$

-   ${}_nl_x={}_nL_x+\color{red}{(n-{}_na_x){}_nd_x}$, por **propiedad distributiva**
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Cuarto bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\color{red}{\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
**Despejando** $l_x$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Quinto bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]$
:::

Recordemos que:

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
$\color{red}{{}_nq_x=\frac{{}_nd_x}{l_x}}$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Sexto bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]$
:::

Recordemos que:

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
${}_nq_x=\frac{{}_nd_x}{l_x} =\color{red}{ \frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
**Sustituyendo** ${}_nl_x$ en ${}_nq_x$. Asi tenemos que:

-   ${}_nq_x = \color{red}{\frac{{}_nd_x}{\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]}}$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Septimo bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]$
:::

Recordemos que:

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
${}_nq_x=\frac{{}_nd_x}{l_x} =\color{red}{ \frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
**Sustituyendo** ${}_nl_x$ en ${}_nq_x$. Asi tenemos que:

-   ${}_nq_x = \frac{{}_nd_x}{\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]} = \color{red}{\frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x}}$
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Octavo bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]$
:::

Recordemos que:

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
${}_nq_x=\frac{{}_nd_x}{l_x}= \frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x} = \color{red}{\frac{\frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x}}{\frac{({}_nL_x+(n-{}_na_x){}_nd_x)}{{}_nL_x}}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Tomando en cuenta que

$\frac{\frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x}}{\frac{({}_nL_x+(n-{}_na_x){}_nd_x)}{{}_nL_x}} = \frac{n\hspace{0.3cm}{}_nd_x\hspace{0.2cm}{}_nL_x}{({}_nL_x+(n-{}_na_x){}_nd_x){}_nL_x} = \frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x}$ aplicando la **ley del sandwich**
:::

## `Método de Greville y Chiang para el cálculo de $L_x$` {auto-animate="true" background-image=Background/bim1.png}

<!-- Noveno bloque -->

Entonces:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=n(l_x-{}_nd_x)+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_nL_x=nl_x-n{}_nd_x+{}_na_x\hspace{0.2cm}{}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$nl_x={}_nL_x+(n-{}_na_x){}_nd_x$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$l_x=\frac{1}{n}[{}_nL_x+(n-{}_na_x){}_nd_x]$
:::

Recordemos que:

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
${}_nq_x=\frac{{}_nd_x}{l_x}= \frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x+(n-{}_na_x){}_nd_x} = \frac{\frac{n\hspace{0.3cm}{}_nd_x}{{}_nL_x}}{\frac{({}_nL_x+(n-{}_na_x){}_nd_x)}{{}_nL_x}} = \frac{n\hspace{0.2cm}{}_nm_x}{1+(n-{}_na_x){}_nm_x}$
:::

## `Repaso de la Tabla de Mortalidad` {background-image=Background/bim1.png}

<!-- Primer bloque -->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_na_x=\frac{-\frac{n}{24}{}_nd_{x-n}+\frac{n}{2}{}_nd_x+\frac{n}{24}{}_nd_{x+n}}{{}_nd_x}$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
Pero cuando $n=1$ entonces ${}_na_x=0.5$
:::

## `Repaso de la Tabla de Mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Segundo bloque -->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_na_x=\frac{-\frac{n}{24}{}_nd_{x-n}+\frac{n}{2}{}_nd_x+\frac{n}{24}{}_nd_{x+n}}{{}_nd_x}$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Pero cuando $n=1$ entonces ${}_na_x=0.5$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Para el último grupo de edad:
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_{\infty}q_x = 1$
:::

## `Repaso de la Tabla de Mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Tercer bloque -->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_na_x=\frac{-\frac{n}{24}{}_nd_{x-n}+\frac{n}{2}{}_nd_x+\frac{n}{24}{}_nd_{x+n}}{{}_nd_x}$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Pero cuando $n=1$ entonces ${}_na_x=0.5$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Para el último grupo de edad:
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_{\infty}q_x = 1$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_{\infty}L_x = \frac{l_x}{{}_{\infty}m_x}$
:::

## `Repaso de la Tabla de Mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Cuarto bloque -->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_na_x=\frac{-\frac{n}{24}{}_nd_{x-n}+\frac{n}{2}{}_nd_x+\frac{n}{24}{}_nd_{x+n}}{{}_nd_x}$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Pero cuando $n=1$ entonces ${}_na_x=0.5$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Para el último grupo de edad:
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_{\infty}q_x = 1$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
${}_{\infty}L_x = \frac{l_x}{{}_{\infty}m_x}$
:::

::: {style="text-align: left; font-size: 1em; margin-top:50px;"}
Finalmente se calculan
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$T_x = \sum_{a=x}^{\infty}{}_nL_a$
:::

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$e_x^0=\frac{T_x}{l_x}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Primer bloque bloque -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Segundo bloque bloque -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Tercer bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=\color{red}{-\frac{dl(x)}{l(x)dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Aplicamos la definición de la **derivada**:

$\lim_{n\to 0}\frac{l_x - l_{x+n}}{nl_x}=\lim_{n\to 0}-\frac{l_{x+n}-l_x}{nl_x}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Cuarto bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=\color{red}{-\frac{dl(x)}{l(x)dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Aplicamos la definición de la **derivada**:

$\lim_{n\to 0}\frac{l_x - l_{x+n}}{nl_x}=\lim_{n\to 0}-\frac{l_{x+n}-l_x}{nl_x}$ factorizando un signo negativo
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Quinto bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=\color{red}{-\frac{dl(x)}{l(x)dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Aplicamos la definición de la **derivada**:

$\lim_{n\to 0}\frac{l_x - l_{x+n}}{nl_x}=\lim_{n\to 0}-\frac{l_{x+n}-l_x}{nl_x}= -\frac{1}{l_x}\lim_{x\to 0}\frac{l_{x+n-l_x}}{n}$ pues el factor $-\frac{1}{l_x}$ no depende de n y lo podemos sacar del límite.
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Sexto bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=\color{red}{-\frac{dl(x)}{l(x)dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Aplicamos la definición de la **derivada**:

$\lim_{n\to 0}\frac{l_x - l_{x+n}}{nl_x}=\lim_{n\to 0}-\frac{l_{x+n}-l_x}{nl_x}= -\frac{1}{l_x}\lim_{x\to 0}\frac{l_{x+n-l_x}}{n}=-\frac{1}{l(x)}\frac{d}{dx}l(x)$ aplicando la definición de la **derivada**
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Septimo bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=\color{red}{-\frac{dInl(x)}{dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Recordemos que:

$\frac{d}{dx}In[l(x)]=\frac{\frac{d}{dx}l(x)}{l(x)}=\frac{dl(x)}{l(x)dx}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Octavo bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=\color{red}{-\frac{dInl(x)}{dx}}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Noveno bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=\color{red}{-\frac{dInl(x)}{dx}}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Sustituyendo $\mu(x)$ del bloque de **Tasa instantánea de mortalidad**
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Noveno bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=\color{red}{-\frac{dInl(x)}{dx}}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx=In[l(z)]-In[l(y)]$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Por **Teorema Fundamental del Cálculo**
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Decimo bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=\color{red}{-\frac{dInl(x)}{dx}}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx=In[l(z)]-In[l(y)] = In[\frac{l(z)}{l(y)}]$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Por **Leyes de los logaritmos**. Para cualquiera números $a,b$, tenemos que $In[\frac{a}{b}]=In(a)-In(b)$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Onceavo bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=-\frac{dInl(x)}{dx}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx=In[l(z)]-In[l(y)] = In[\frac{l(z)}{l(y)}]$

$\implies \color{red}{l(z)=l(y)e^{-\int_y^z\mu(z)dx}}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Despejando $l(z)$:

-   $e^{-\int_y^z\mu(x)dx}=e^{In[\frac{l(z)}{l(y)}]}$ aplicando $e^x$ para todo $x$

-   $e^{-\int_y^z\mu(x)dx}=\frac{l(z)}{l(y)}$ pues $e^{In(x)}=x$ para todo $x$

-   $l(z)=l(y)e^{-\int_y^z\mu(x)dx}$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Doceavo bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=-\frac{dInl(x)}{dx}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx=In[l(z)]-In[l(y)] = In[\frac{l(z)}{l(y)}]$

$\implies \color{red}{l(z)=l(y)e^{-\int_y^z\mu(z)dx}}$

Entonces: $l(x)=l(0)e^{-\int_0^x\mu(t)dt}$
:::

::: {.callout-warning title="La trampa esta en los pormenores "}
Si tomamos en cuenta $y=x$ y $z=0$
:::

## `Relaciones básicas de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- 13 bloque  -->

::: {.callout-note title="Tasa instantánea de mortalidad"}
$\mu(x)= \lim_{n\to 0}{}_nm_x = \lim_{n\to 0}\frac{{}_nd_x}{{}_nL_x} = \lim_{n\to 0}\frac{l_x-l_{x+n}}{nL_x}=-\frac{dl(x)}{l(x)dx}=-\frac{dInl(x)}{dx}$
:::

::: {.callout-note title="Función de supervivencia"}
$-\int_y^z\mu(x)dx=\int_y^z\frac{d}{dx}In[l(x)]dx=In[l(z)]-In[l(y)] = In[\frac{l(z)}{l(y)}]$

$\implies \color{red}{l(z)=l(y)e^{-\int_y^z\mu(z)dx}}$

Entonces: $l(x)=l(0)e^{-\int_0^x\mu(t)dt}$

Si tomamos $l(0)=1$, obtenemos:

$l(x)=e^{-\int_0^x\mu(t)dt}$
:::

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 1 bloque  -->

Definamos a $X$ como al evento de que una persona muere en un tiempo $t$. Entoces tenemos que:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$q(X)= \lim_{\Delta t \to 0}\frac{P(X\in(x,x+\Delta))}{\Delta t}$
:::

es una **función de densidad**. Y

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$Q(x)=P(X\leq x)= \int q(x)dx$
:::

es una **función de distribución**

::: {.callout-warning title="La trampa esta en los pormenores "}
Vayamos con calma en este bloque. Una **función de densidad** o **función de probabilidad**,$f$,es una función que cumple con las siguinetes tres propiedades.

-   $f(x)>0$, es decir, es positiva para todo $x$ en su dominio o sus valores permitidos.

-   $\int_{Dom(x)}f(x)=1$, es decir, la integral sobre todo el dominio de la función $f$ es 1.

-   $f(x)\leq 1$ es decir, es menor o igual a 1
:::

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 2 bloque  -->

Definamos a $X$ como al evento de que una persona muere en un tiempo $t$. Entoces tenemos que:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$q(X)= \lim_{\Delta t \to 0}\frac{P(X\in(x,x+\Delta t))}{\Delta t}$
:::

es una **función de densidad**. Y

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$Q(x)=P(X\leq x)= \int q(x)dx$
:::

es una **función de distribución**

::: {.callout-warning title="La trampa esta en los pormenores "}
Porque son importantes las **funciones de probabilidad**?

-   Como su nombre lo sugiere, estas funciones nos permitirán calcular probabilidades de nuestros eventos.
-   f(x)=P(X=x) se lee como, la probabilidad de que X sea igual al evento x.
-   En nuestro contexto, se lee como la probabilidad de que una persona muera en el tiempo determinado $x$.
:::

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 3 bloque  -->

Definamos a $X$ como al evento de que una persona muere en un tiempo $t$. Entoces tenemos que:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$q(X)= \lim_{\Delta t \to 0}\frac{P(X\in(x,x+\Delta t))}{\Delta t}$
:::

es una **función de densidad**. Y

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$Q(x)=P(X\leq x)= \int q(x)dx$
:::

es una **función de distribución**

::: {.callout-note title="Tasa instantanea de mortalidad"}
$\mu(X)= \lim_{\Delta x \to0} \frac{P(X\in (x,x+\Delta x)|Se\,llegó\, con \,vida\, al\, tiempo\,x )}{\Delta x}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
$\mu(X)= \lim_{\Delta x \to0} \frac{P(X\in (x,x+\Delta x)|Se\,llegó\, con \,vida\, al\, tiempo\,x )}{\Delta x}$
:::

<!-- Explicacion de la probabilidad condicional un bloque-->

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 4 bloque  -->

Definamos a $X$ como al evento de que una persona muere en un tiempo $t$. Entoces tenemos que:

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$q(X)= \lim_{\Delta t \to 0}\frac{P(X\in(x,x+\Delta t))}{\Delta t}$
:::

es una **función de densidad**. Y

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$Q(x)=P(X\leq x)= \int q(x)dx$
:::

es una **función de distribución**

::: {.callout-note title="Tasa instantanea de mortalidad"}
$\mu(X)= \lim_{\Delta x \to0} \frac{P(X\in (x,x+\Delta x)|Se\,llegó\, con \,vida\, al\, tiempo\,x )}{\Delta x}$
:::

::: {.callout-warning title="El diablo esta en los detalles"}
$\mu(X)= \lim_{\Delta x \to0} \frac{P(X\in (x,x+\Delta x)|Se\,llegó\, con \,vida\, al\, tiempo\,x )}{\Delta x}$

$\frac{q(X)}{1-Q(X)}=\frac{q(X)}{l(X)}$
:::

<!-- Explicar el cociente y la funcion de supervivencia  -->

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 1 bloque  -->

::: {.callout-note title="Función de sobrevivencia"}
Como $q(X)$ es una función de densidad, entonces:

$q(X) = \frac{dQ(X)}{dx}=\frac{d[1-l(X)]}{dx}=-\frac{dl(X)}{dx}$ <!-- Explicar la derivada de una constante 1 bloque  -->
:::

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 2 bloque  -->

::: {.callout-note title="Función de sobrevivencia"}
Como $q(X)$ es una función de densidad, entonces:

$q(X) = \frac{dQ(X)}{dx}=\frac{d[1-l(X)]}{dx}=-\frac{dl(X)}{dx}$

por lo que

$\mu(X)=\frac{q(X)}{l(X)}=-\frac{dl(X)}{l(X)dx}=-\frac{dIn[l(X)]}{dx}$
:::

## `Relaciones básicas de la mortalidad (otra perspectiva)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 3 bloque  -->

::: {.callout-note title="Función de sobrevivencia"}
Como $q(X)$ es una función de densidad, entonces:

$q(X) = \frac{dQ(X)}{dx}=\frac{d[1-l(X)]}{dx}=-\frac{dl(X)}{dx}$

por lo que

$\mu(X)=\frac{q(X)}{l(X)}=-\frac{dl(X)}{l(X)dx}=-\frac{dIn[l(X)]}{dx}$

de lo que se sigue que:

$l(x)=e^{-\int_0^x \mu(t)dt}$
:::

## `Relaciones básicas de la mortalidad (resumen)` {auto-animate="true" background-image=Background/bim1.png}

<!-- 1 bloque  -->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
-   $\mu(x)=-\frac{dIn[l(x)]}{dx}$
-   $l(x)=e^{-\int_0^x\mu(t)dt}$
-   $q(x)=\mu(x)e^{-\int_0^x\mu(t)dt}$
:::

## `Patrones modelo de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- 1 bloque  -->

::: {.callout-note title="Modelo de Gompertz"}
$\mu(x)=BC^x$
:::

## `Patrones modelo de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- 2 bloque  -->

::: {.callout-note title="Modelo de Gompertz"}
$\mu(x)=BC^x$
:::

::: {.callout-note title="Modelo de Gompertz-Makeham"}
$\mu(x)=A+BC^x$
:::

## `Patrones modelo de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- 3 bloque  -->

::: {.callout-note title="Modelo de Gompertz"}
$\mu(x)=BC^x$
:::

::: {.callout-note title="Modelo de Gompertz-Makeham"}
$\mu(x)=A+BC^x$
:::

::: {.callout-note title="Modelo de Weibull"}
$\mu(x)=kx^n$
:::

## `Patrones modelo de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- 3 bloque  -->

::: {.callout-note title="Modelo de Gompertz"}
$\mu(x)=BC^x$
:::

::: {.callout-note title="Modelo de Gompertz-Makeham"}
$\mu(x)=A+BC^x$
:::

::: {.callout-note title="Modelo de Weibull"}
$\mu(x)=kx^n$
:::

::: {.callout-note title="Modelo de Heligman y Pollard"}
$\mu(x)=A^{(x+B)^C}+De^{-E(In(x)-In(F)^2)}+GH^x$
:::

## `Patrones modelo de la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

![](Input/mortalidad.png)

## `Otras relaciones en la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 1-->

<!-- Preguntar por el nombre de la ecuacion 1-->

::: {.callout-note title="Ecuacion 1"}
${}_nL_x=\int_0^nl(x+t)dt$
:::

## `Otras relaciones en la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 2-->

<!-- Preguntar por el nombre de la ecuacion 1-->

::: {.callout-note title="Ecuacion 1"}
${}_nL_x=\int_0^nl(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 2-->

::: {.callout-note title="Ecuacion 2"}
${}_nd_x=\int_0^nl(x+t)\mu(x+t)dt$
:::

## `Otras relaciones en la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 3-->

<!-- Preguntar por el nombre de la ecuacion 1-->

::: {.callout-note title="Ecuacion 1"}
${}_nL_x=\int_0^nl(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 2-->

::: {.callout-note title="Ecuacion 2"}
${}_nd_x=\int_0^nl(x+t)\mu(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 3-->

::: {.callout-note title="Ecuacion 3"}
$T_x=\int_0^{\omega-x}l(x+t)dt=\int_0^{\omega-x}l(x+t)dt$
:::

## `Otras relaciones en la mortalidad` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 4-->

<!-- Preguntar por el nombre de la ecuacion 1-->

::: {.callout-note title="Ecuacion 1"}
${}_nL_x=\int_0^nl(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 2-->

::: {.callout-note title="Ecuacion 2"}
${}_nd_x=\int_0^nl(x+t)\mu(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 3-->

::: {.callout-note title="Ecuacion 3"}
$T_x=\int_0^{\omega-x}l(x+t)dt=\int_0^{\omega-x}l(x+t)dt$
:::

<!-- Preguntar por el nombre de la ecuacion 4-->

::: {.callout-note title="Ecuacion 4"}
$e_x=\frac{\int_0^{\omega-x}t*l(x+t)\mu(x+t)dt}{\int_0^{\omega-x}l(x+t)\mu(x+t)dt}=\frac{\int_0^{\omega-x}l(x+t)dt}{l(x)}$
:::

## `Modelos relacionales de la mortalidad (Brass 1971)` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 1-->

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$\hat{Y}(x)=logit[q(x)]=0.5In\left[ \frac{q(x)}{1-q(x)} \right]$

$\hat{Y}(x)=\alpha+\beta\hat{Y}^S(x)$
:::

## `Proyección logística de la mortalidad` {background-image=Background/bim1.png}

<!-- Bloque 1-->

::: {style="text-align: center; font-size: 3em; margin-top:300px;"}
$e_0(t)=k_1+\frac{k_2}{1+e^{a+bt}}$
:::

## `El modelo de Lee y Carter` {background-image=Background/bim1.png}

<!-- Bloque 1-->

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$In(m_{x,t})=a_x+b_xk_t+\epsilon_{x,t}$
:::

sujeto a:

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$\sum_{t=0}^n k_t=0$

$\sum_{t=0}^{\omega} b_x=0$
:::

## `Estimación 1.Descomposición de Valores Singulares` {background-image=Background/bim1.png}

<!-- Bloque 1-->

Dada las restricciones del modelo, se sigue que:

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"} 

$\sum_{t=0}^n In(m_{x,t})=\sum_{t=0}^n a_z + \sum_{t=0}^n b_xk_t$

$\sum_{t=0}^{\omega} In(m_{x,t})=na_x$

:::

Por lo que:

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$\hat{a}=\frac{\sum_{t=1}^n In(m_{x,t})}{n}$
:::

Entonces:

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$In(m_{x,t})-\hat{a}=b_xk_t$
:::

## `Descomposición en Valores Singulares` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 1-->

Formalmente, la factorización DVS indica que para toda $\textbf{A} \in \mathbb{R}^{m\times n}$ de rango $r$, existen matrices ortogonales $\textbf{U}_{m\times n}$ y $\textbf{V}_{n\times n}$ y una matriz diagonal $\textbf{D}_{n\times n}=diag(\sigma_1,\sigma_2,...,\sigma_n)$ tales que: 

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"} 
$\textbf{A}=\textbf{UDV}^t\,\sigma_1\geq\sigma_2\geq...\geq \sigma_n$
:::

Las $\sigma_i^{'}s$ son los valores singulares de $\textbf{A}$. En la factorización anterior, a las solumnas de $\textbf{U}$ y $\textbf{V}$ se les denomina vectores singulares de $\textbf{A}$ izquierdos y derechos, respectivamente. Entonces $b_x$ se encuentra estimado por el primer vector propio izquierdo y $k_t$ está determinado por la primera componente principal considerando el primer vector propio derecho determinado por el máximo eigenvalor $\sigma_1$. De hecho, en general:

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$In(m_{x,t})=a_x+b_{x1}k_{kt1}+b_{x2}k_{t2}+...+b_{xn}k_{tn}$
:::

donde, $\epsilon_{x,t}=b_{x2}k_{t2}+...+b_{xn}k_{tn}$

## `Criterios de minimización` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 1-->

El criterio de minimización apropiado se encuentra dado por el cálculo de la devianza: 

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"} 
$devianza_t = 2\sum_{x=0}^{\omega+} \left[D_{x,t}In\left( \frac{D_{x,t}}{D^{'}_{x,t}} \right)-(D_{x,t}-D^{'}_{x,t}) \right]$

:::

La devianza es imilar al cálculo de la prueba $\chi-cuadrada$ para la bondad de ajuste de $D^{'}_{x,t}$ además de que el cálculo es mas sencillo: 

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"} 
$\chi^2=\sum_{t=1}^n\sum_{x=0}^{\omega+}\left[ \frac{(D_{x,t}-D^{'}_{x,t})^2}{D^{'}_{x,t}} \right]$

:::

donde $D_{x,t}$ son las defunciones totales de los individuos a edad $x$ ocurridas durante el año $t$. Esta ecuación es utilizada para comparar la bondad de ajuste entre los modelos, el criterio de discriminación es: aquel modelo que presente la $\chi^2$ menor es el que ajusta mejor a los datos de las defunciones.



## `Coeficiente de determinación` {background-image=Background/bim1.png}

<!-- Bloque 1-->

::: {style="text-align: center; font-size: 1.5em; margin-top:100px;"}
$R^2 = 1 - \frac{\sum_{t=1}^{n} \sum_{x=0}^{w+} \left[ \ln(m_{x,t}) - a_x - b_x k_t \right]^2}{\sum_{t=1}^{n} \sum_{x=0}^{w+} \left[ \ln(m_{x,t}) - a_x \right]^2}$

$= 1 - \frac{\sum_{t=1}^{n} \sum_{x=0}^{w+} \varepsilon_{x,t}^2}{\sum_{t=1}^{n} \sum_{x=0}^{w+} \left[ \ln(m_{x,t}) - a_x \right]^2}.$
:::

## `Estimación 2. Brooth`*et al*`(2001)` {auto-animate="true" background-image=Background/bim1.png}

<!-- Bloque 1-->

Refinamiento, habiendo estimado $a_x$ y $b_x$ de acuerdoa LC

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$k_t=\frac{In(m_{x,t})-a_{x,1}}{b_{x,1}}$
:::

## `Estimación 3. LC alternativo` {auto-animate="true" background-image=Background/bim1.png}

Habiendo estimado $a_x$

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$k_t=\sum{}_{x=0}^{\omega}(In(m_{x,t})-a_x)$
:::

Entonces, $b_x$ se estima por MCO

::: {style="text-align: center; font-size: 1em; margin-top:50px;"}
$b_x=\frac{\sum{}_{x=0}^{\omega}(In(m_{x,t})-a_x)}{\sum_{t=0}^{n}k_t^2}$
:::




